package org.mal_lang.kvmlang.test;

import core.Attacker;
import core.AttackStep;
import org.junit.jupiter.api.Test;

public class InstanceExploitTest extends KVMLangTest{

    private static class InstanceExploitModel {
        /**First model has no defenses active.
        * Second model has Patching active.
        * 
        * */  
        /**   First model   */
        public final Instance instance1 = new Instance("instance1");
        public final QemuKVM hypervisor1 = new QemuKVM("hypervisor1", false);
        public final Data data1 = new Data("data1", false);
        public final Data data2 = new Data("data2", false);
      

        /**Application*/
        public final Application application1 = new Application("application1");

        /**---Second model--*/

        public final Instance instance2 = new Instance("instance2");
        public final QemuKVM hypervisor2 = new QemuKVM("hypervisor2",true);
        public final Data data3 = new Data("data3", false);
        public final Data data4 = new Data("data4", false);
        public final Data data5 = new Data("data5", true);

        public final Application application2 = new Application("application2");

        public InstanceExploitModel() {
            hypervisor1.addSysExecutedInstances(instance1);
            instance1.addContainedData(data1);
            instance1.addGuestSysExecutedApps(application1);
            application1.addContainedData(data2);
            /**---Second model--*/
            hypervisor2.addSysExecutedInstances(instance2);
            instance2.addContainedData(data3);
            instance2.addContainedData(data5);
            instance2.addGuestSysExecutedApps(application1);
            application2.addContainedData(data4);

        }

        public void addAttacker(Attacker attacker, AttackStep attackpoint) {
            attacker.addAttackPoint(attackpoint);
        }
    }

    @Test
    public void testExploitBufferOverflowInstance1TC8() {
      printTestName(Thread.currentThread().getStackTrace()[1].getMethodName());
      var model = new InstanceExploitModel();
  
      var attacker = new Attacker();
      model.addAttacker(attacker,model.instance1.connect);
      model.addAttacker(attacker,model.instance1.authenticate);
      attacker.attack();
  
      //Access to instance
      model.instance1.authenticatedAccess.assertCompromisedInstantaneously();
      model.instance1.fullAccess.assertCompromisedInstantaneously();
      //Attempt Buffer overflow
      model.instance1.deviceEmulationExploit.assertCompromisedInstantaneously();
      model.instance1.improperMemoryBounds.assertCompromisedInstantaneously();
      model.instance1.attemptExploitBufferOverflow.assertCompromisedInstantaneously();
      model.hypervisor1.bufferOverflow.assertCompromisedInstantaneously();
      model.hypervisor1.guestInstanceDOS.assertCompromisedInstantaneously();
      //Successful attempt leads back to deny on instance.
      model.instance1.deny.assertCompromisedInstantaneously();
      //Application is denyed, leads to denial of data.
      model.application1.deny.assertCompromisedInstantaneously();
      model.data2.deny.assertCompromisedInstantaneously();
      
    }

    @Test
    public void testExploitoutOfBoundsRead_Instance1_TC9() {
      printTestName(Thread.currentThread().getStackTrace()[1].getMethodName());
      var model = new InstanceExploitModel();
  
      var attacker = new Attacker();
      model.addAttacker(attacker,model.instance1.connect);
      model.addAttacker(attacker,model.instance1.authenticate);
      attacker.attack();
  
      //Access to instance
      model.instance1.authenticatedAccess.assertCompromisedInstantaneously();
      model.instance1.fullAccess.assertCompromisedInstantaneously();
      //Attempt OutOfBoundsRead
      model.instance1.deviceEmulationExploit.assertCompromisedInstantaneously();
      model.instance1.outOfBoundsRead.assertCompromisedInstantaneously();
      model.instance1.attemptExploitOutOfBoundsRead.assertCompromisedInstantaneously();
      model.hypervisor1.outOfBoundsReadORWrite.assertCompromisedInstantaneously();
      model.hypervisor1.guestInstanceDOS.assertCompromisedInstantaneously();
      //Successful attempt leads back to deny on instance.
      model.instance1.deny.assertCompromisedInstantaneously();
      //Application is denyed, leads to denial of data.
      model.application1.deny.assertCompromisedInstantaneously();
      model.data2.deny.assertCompromisedInstantaneously();
      
    }
    @Test
    public void testNullPointerDereference_Instance1_TC10() {
      printTestName(Thread.currentThread().getStackTrace()[1].getMethodName());
      var model = new InstanceExploitModel();
  
      var attacker = new Attacker();
      model.addAttacker(attacker,model.instance1.connect);
      model.addAttacker(attacker,model.instance1.authenticate);
      attacker.attack();
  
      //Access to instance
      model.instance1.authenticatedAccess.assertCompromisedInstantaneously();
      model.instance1.fullAccess.assertCompromisedInstantaneously();
      //Attempt OutOfBoundsRead
      model.instance1.deviceEmulationExploit.assertCompromisedInstantaneously();
      model.instance1.nullPointerDereference.assertCompromisedInstantaneously();
      model.instance1.attemptNullPointerDereference.assertCompromisedInstantaneously();
      model.hypervisor1.nullPointerDereference.assertCompromisedInstantaneously();
      model.hypervisor1.guestInstanceDOS.assertCompromisedInstantaneously();
      //Successful attempt leads back to deny on instance.
      model.instance1.deny.assertCompromisedInstantaneously();
      //Application is denyed, leads to denial of data.
      model.application1.deny.assertCompromisedInstantaneously();
      model.data2.deny.assertCompromisedInstantaneously();
      
    }

    @Test
    public void testActivePatch_Instance2_TC11() {
      printTestName(Thread.currentThread().getStackTrace()[1].getMethodName());
      var model = new InstanceExploitModel();
  
      var attacker = new Attacker();
      model.addAttacker(attacker,model.instance2.connect);
      model.addAttacker(attacker,model.instance2.authenticate);
      attacker.attack();
  
      //Access to instance
      model.instance2.authenticatedAccess.assertCompromisedInstantaneously();
      model.instance2.fullAccess.assertCompromisedInstantaneously();
      //Attempt attempt attack hypervisor via instance
      model.instance2.deviceEmulationExploit.assertCompromisedInstantaneously();
      model.instance2.nullPointerDereference.assertCompromisedInstantaneously();
      model.instance2.attemptNullPointerDereference.assertCompromisedInstantaneously();
      model.hypervisor2.bufferOverflow.assertUncompromised();
      model.hypervisor2.outOfBoundsReadORWrite.assertUncompromised();
      model.hypervisor2.nullPointerDereference.assertUncompromised();
      model.hypervisor2.guestInstanceDOS.assertUncompromised();
    }
    @Test
    public void testApplicationDenialVia_Instance1_TC12() {
      printTestName(Thread.currentThread().getStackTrace()[1].getMethodName());
      var model = new InstanceExploitModel();
  
      var attacker = new Attacker();
      model.addAttacker(attacker,model.instance1.connect);
      model.addAttacker(attacker,model.instance1.authenticate);
      attacker.attack();
  
      //Access to instance
      model.instance1.authenticatedAccess.assertCompromisedInstantaneously();
      model.instance1.fullAccess.assertCompromisedInstantaneously();
      //Attempt DOS on application via instance
      model.instance1.deny.assertCompromisedInstantaneously();
      model.application1.deny.assertCompromisedInstantaneously();
      model.data2.deny.assertCompromisedInstantaneously();
   
    }
    @Test
    public void testDataMissing_Instance2_TC15() {
      printTestName(Thread.currentThread().getStackTrace()[1].getMethodName());
      var model = new InstanceExploitModel();
  
      var attacker = new Attacker();
      model.addAttacker(attacker,model.instance2.connect);
      model.addAttacker(attacker,model.instance2.authenticate);
      attacker.attack();
  
      //Access to instance
      model.instance2.authenticatedAccess.assertCompromisedInstantaneously();
      model.instance2.fullAccess.assertCompromisedInstantaneously();
      //Attempt attempt find missing data
      model.data5.read.assertUncompromised();
      model.data5.delete.assertUncompromised();
      model.data5.readContainedInformationAndData.assertUncompromised();
      model.data5.write.assertUncompromised();

    }    
    
}